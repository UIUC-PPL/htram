module htram_group{
//  readonly CProxy_HTram tram_proxy;
//  readonly CProxy_HTramRecv nodeGrpProxy;
//  readonly CProxy_HTramNodeGrp srcNodeGrpProxy;
  initnode void registerMsgStatsCollection(void);
  message HTramMessage {
    int next;
    int track_count;
    int srcPe;
    int *ack_count;
    itemT *buffer;
  };

  message HTramLocalMessage {
    itemT *buffer;
    int next;
  };
  message HTramNodeMessage {
    datatype *buffer;
    int *offset;
    int track_count;
  };
  group HTram {
    entry HTram(CkGroupID, CkGroupID, int, bool, double, bool, bool, CkCallback);
    entry HTram(CkGroupID gid, CkCallback cb);
    entry void avgLatency(CkCallback cb);
    entry void tflush();
    entry void trackflush();
    entry void getRecvCount();
    entry void resetCounts();
    entry void sanityCheck();
    entry void releaseMessages();
    entry [reductiontarget] void checkCounts(int);
    entry [reductiontarget] void getTotSends(int);
    entry [reductiontarget] void getTotSendCount(int);
    entry [reductiontarget] void getTotRecvCount(int);
    entry void global_flush(CkCallback cb);
    entry [whenidle] bool idleFlush();
    entry void receivePerPE(HTramMessage*);
    entry [expedited] void receiveOnPE(HTramMessage* msg);
    entry void receivePerPE(HTramNodeMessage*);
    entry void stop_periodic_flush();
  };

  nodegroup HTramNodeGrp {
    entry HTramNodeGrp();
  };

  nodegroup HTramRecv {
    entry HTramRecv();
    entry [expedited] void receive(HTramMessage*);
    entry [expedited] void receive_no_sort(HTramMessage*);
    entry void receive_small(HTramLocalMessage*);
    entry void avgLatency(CkCallback cb);
  }
};
